====== RJ45 Tester ======

===== Introducere =====

==== Ideea de la care am pornit ====

VƒÉ aminti»õi primul laborator de **RL**?

Acolo am √ÆnvƒÉ»õat cum sƒÉ realizƒÉm un **cablu UTP** pentru re»õele Ethernet,
Procesul poarta numele de **sertizare**.
DupƒÉ realizarea cablului, acesta trebuie verificat ca functioneaza corect - adicƒÉ dacƒÉ are continuitate.

Testarea se face folosind un dispozitiv dedicat.

De aici a pornit ideea proiectului meu: realizarea propriului meu [[https://www.optimusdigital.ro/ro/aparate-de-masura/4962-tester-rj45-rj11.html?search_query=rj45&results=22|tester RJ45]],
caruia i-am adus o serie de √ÆmbunƒÉtƒÉ»õiri.

==== Care este scopul proiectului? ====

Dispozitivul proiectat permite testarea cablurilor de re»õea de tip **RJ45**, oferind feedback vizual »ôi auditiv privind corectitudinea conexiunilor dintre pini.

Prin simpla apƒÉsare a unui buton, utilizatorul poate selecta tipul de cablu testat:
  - **Straight-through** ‚Äì pentru conectarea dispozitivelor aflate pe //layere diferite// (ex: PC ‚Äì switch)
  - **Crossover** ‚Äì pentru conectarea dispozitivelor de //acela»ôi layer// (ex: PC ‚Äì PC)

DupƒÉ selectare, pe ecranul principal (128x160 SPI) este afi»ôatƒÉ o imagine cu ordinea corectƒÉ a firelor pentru tipul respectiv de cablu.

==== Ce face? ====

  * Se folosesc 2 socketi: unul dedicat pentru **sender**, iar celƒÉlalt pentru **receiver**
  * Fiecare soclu RJ-45 are 8 pini
  * FiecƒÉrui pin RJ-45 √Æi este asociat un LED de culoare verde care se va aprinde atunci c√¢nd semnalul transmis/primit pe pinul respectiv este de 1 logic.
  * √én momentul √Æn care socket-ul de **receiver** recep»õioneazƒÉ **1 logic**, buzzer-ul va emite un beep scurt

Testarea efectivƒÉ presupune 2 verificƒÉri:


  - Se vor trimite semnale, secven»õial, iter√¢nd pinii **sender**-ului unul c√¢te unul, cu mici pauze √Æntre transmisii,
  - urm√¢nd un test final √Æn care se vor activa simultan to»õi pinii **sender**-ului

Testarea poate fi opritƒÉ for»õat, √Æn orice moment, prin apƒÉsarea unui buton.

√én timp ce display-ul pe SPI (de rezolu»õie mai mare) afi»ôeazƒÉ ordinea firelor √Æn mufa RJ-45, LCD-ul cu modul I2C va scrie pe ecran tipul de cablu **straight-through**\**crossover** »ôi indexul pinului de pe **sender** de pe care se trimit semnale (ex: //Testing pin 1...8//), sau mesajul //Testing all pins//.

==== De ce este util? ====

Consider cƒÉ folosirea ecranelor face diferen»õa dintre un tester RJ-45 obi»ônuit »ôi acest dispozitiv.

Practic, este un instrument **‚Äû2 √Æn 1‚Äù**: tester + ghid de conectare.

Sper ca dispozitivul pe care √Æl proiectez (√Æmi propun sƒÉ √Æi fac »ôi un **PCB compact**) sƒÉ ajungƒÉ √Æn m√¢inile laboran»õilor de RL/CCNA1. Acolo √Æ»ôi va atinge adevƒÉratul poten»õial.
===== Descriere Generala =====


Schema bloc:

{{:pm:prj2025:ajipa:rj45-tester-schema-bloc.jpg?600}}



===== Hardware Design =====


==== Lista Componente ====

    * [[https://www.emag.ro/placa-de-dezvoltare-nano-v3-0-atmega328p-ch340-cu-cablu-usb-1414dr/pd/DTDC88YBM/?ref=history-shopping_415312802_171246_1|Arduino Nano V3.0]]
    * 2x [[https://www.aliexpress.com/item/1005006421216570.html?spm=a2g0o.productlist.main.1.7a83OBnaOBnaHZ&algo_pvid=00f91974-4220-41f5-8c1c-f9375b3e09d7&pdp_ext_f=%7B%22order%22%3A%22150%22%2C%22eval%22%3A%221%22%7D&utparam-url=scene%3Asearch%7Cquery_from%3A|RJ45 Adapter Board + Breakout Board + Pin Header]] (de pe AliExpress üòä)
    * 1x [[https://ardushop.ro/ro/circuite-integrate/1657-ic-shift-register-sn74hc595n-74hc595-6427854024978.html|74HC595 8-bit Shift Register]] (fiecare are 8 pini de iesiri)
    * 1x [[https://ardushop.ro/ro/electronica/683-74hc165-8-bit-shift-register-6427854008602.html|74HC165 8-bit Shift Register]] (8 pini de intrare)
    * [[https://www.optimusdigital.ro/ro/optoelectronice-lcd-uri/2894-lcd-cu-interfata-i2c-si-backlight-albastru.html?search_query=0104110000003584&results=1|LCD 16x02 cu interfata I2C]]
    * [[https://ardushop.ro/ro/electronica/2124-modul-lcd-spi-128x160-6427854032546.html|Modul LCD SPI 128x160]]
    * 16x [[https://www.optimusdigital.ro/ro/optoelectronice-led-uri/697-led-verde-de-3-mm-cu-lentile-difuze.html?search_query=0104210000006209&results=1|LED Verde cu lentile difuze]]
    * [[https://www.optimusdigital.ro/ro/componente-electronice/12598-modul-buzzer-pasiv.html?search_query=0104110000082985&results=1|Modul Buzzer Pasiv]]
    * 3x [[https://www.optimusdigital.ro/ro/butoane-i-comutatoare/1115-buton-cu-capac-rotund-alb.html?search_query=buton+cu+capac&results=29|Buton cu Capac Rotund]]
    * 3x Rezistente (de PULL-UP) de 10 kŒ© (pt butoane)
    * 3x Condensatoare ceramice de 47nF (pt butoane)
    * 3 breadboard-uri 830 puncte



==== Pin configurations ====

===== Arduino =====





==== Schema electrica ====


{{:pm:prj2025:ajipa:rj45-schematics.jpg?800}}


==== Debounce butoane: Filtru trece-jos ====

Pentru a trata **debounce-ul butoanelor** exclusiv din hardware,
m-am gandit sa introduc in circuit un **filtru trece-jos**,
punand cate un condensator ceramic in paralel cu fiecare buton.

Constanta de timp œÑ:

<note tip>
œÑ = R*C =10kŒ©*47nF = 10^4 + 47*10^(-9) = 47*10^(-5) = 470us

5*œÑ=5*470Œºs‚âà2.35ms
</note>


Astfel, schimbarile mai rapide de **2.35 ms** ale butoanelor
vor fi ignorate (la nivel hardware) de aceste filtre.

<note warning>
Chiar si asa, eu tot am lasat in cod un mic **delay**
(unul mult mai mare decat ce poate circuitul construit de mine sa filtreze).
</note>



==== Progresul fizic, pe etape ====

{{:pm:prj2025:ajipa:rj45-hw-stage-1.jpeg?500}}
{{:pm:prj2025:ajipa:rj45-hw-stage-2.jpeg?500}}
{{:pm:prj2025:ajipa:rj45-hw-stage-3.jpeg?300}}



===== Software Design =====


Biblioteci folosite:
  * **Arduino.h**: biblioteca default pentru placa de dezvoltare
  * **LiquidCrystal_I2C.h**: imi permite scrierea caracterelor pe ecranul secundar (cel pe I2C, de rezolutie 16x02)
  * **Adafruit_GFX.h**, **Adafruit_ST7735.h**: pentru interactiunea cu display-ul principal (cel pe SPI, de rezolutie 128x160)

Repo GitHub: <https://github.com/TrifanBogdan24/RJ45-tester> - codul sursa se gaseste in folderul **src/**.



Am asociat fiecarui buton cate o intrerupere:
  * Butonul **albastru** - intreruperea **INT0** - schimba tipul de cablare (crossover/straigh-through)
  * Butonul **rosu** - intreruperea **INT1** - opreste fortat rularea testului
  * Butonul **alb** - intreruperea **PCINT20** (din **PCINT2_vect**)  - porneste algoritmul de testare:

Descrierile functiilor:
  * **ISR(INT0_vect)**:
    * rutina de tratare a intreruperii, generata la apasarea butonului **albastru** (schimba tipul de cablare)
    * Marcheaza flag-ul **volatile bool pressedBTN1**
  * **ISR(INT1_vect)**: 
    * rutina de tratare a intreruperii, generata la apasarea butonului **rosu** (oprirea fortata a algoritmului de testare)
    * Marcheaza flag-ul **volatile bool pressedBTN2**
  * **ISR(PCINT2_vect)**:
    * rutina de tratare a intreruperii, generata la apasarea butonului **alb** (pornirea algoritmului de testare)
    * Marcheaza flag-ul **volatile bool pressedBTN3**
  * **void beep_okay()**:
    * controleaza buzzer-ul sa emita bazait scurt, in semn ca totul este in regula
  * **void beep_not_okay()**:
    * controleaza buzzer-ul sa emita un semnal sonor de eroare
  * **void cable_type_first_line_lcd()**:
    * scrie tipul de cablare pe prima linia a LCD-ului de rezolutie 16x02
  * **void cable_mode_full_lcd()**:
    * scrie pe textul "Mode:" pe prima linia a display-ului secundar (cel pe I2C, de 16x02),
    * iar pe a doua, tipul de cablare
  * **void force_stop_handler()**:
    * Functia este apelata in urma apasarii butonului **rosu**.
    * Opreste fortat algoritmul de testare,
    * dar nu inainte de a afisa pe ecranul LCD pe I2C un mesaj sugestiv in acest sens
    * **lcd.print("Force stop!");**
  * **void write_to_sender_socket()**:
    * Variabila **bool pinsSenderSocket[8]** retine starea pinilor din mufa RJ-45 de transmisie
    * Functia scrie valorile din **bool pinsSenderSocket[8]** in shift register-ul **74HC595**,
    * Scrierea (chiar si pe un singur pin) al socket-ului sender presupune scrierea tuturor celor 8 valori catre **shift register**, in ordine inversa (intrucat acesta foloseste **MSB**: prima valoare primita va fi asociata ultimului pin)
  * **void init_sender_pins()**:
    * Este apelata la pornirea micro-controler-ului
    * pentru a trata starea initiala indefinita
    * (uneori LED-uri se pot aprinde aleator, fara ca eu nici macar sa fi scris ceva in shift register)
    * a shift register-ului **74HC595**, asociat socket-ului sender.
  * **void fetch_receiver_socket()**:
    * Citeste valorile de pe shift register-ul **74HC165** (asociat socket-ului receiver)
    * si le scrie in variabila **bool pinsReceiverSocket[8];**
  * **bool is_correct_wiring(int pin_index)**:
    * Apeleaza **is_correct_wiring** pentru a citi semnalele de pinii socket-ului receiver
    * Si verifica daca valorile corespund unei cablari corecte, in raport cu indexul pinului activat pe mufa RJ-45 de transmisie
  * **int test_individual_rj45_pins()**:
    * Algoritmul propriu zis de testare
    * Parcurge iterativ, de la 1 la 8, toti pinii socket-ului sender si
      * Scrie pe ecranul secundar (16x02): modul de cablare, indexul pinului RJ-45 de transmisie si indexul corect pe care se asteapta sa primeasca semnal de pe pinul RJ-45 de receptie
      * Scrie "1 logic" in iesirea (shift register-ului) **74HC595** corespunzatoare pinului ales: lucru care va produce aprinderea unui LED
      * Ruleaza un mic **delay()** pentru a ma asigura ca semnalul are timp sa ajunga de la un capat la altul
      * Apeleaza functia **is_correct_wiring** pentru a afla daca semnalul ajuns unde trebuie:
        * Daca da, va scrie in //"OK"// in coltul dreapta-jos al display-ului secundar si va emite un bapait scurt
        * Altfel, va scrie //"NOK"// pe LCD si va produce un sunet de avertistment
    * Functia verifica constant daca butonul **rosu** a fost apasat (flag-ul **pressedBTN2** a fost setat), caz in care opreste fortat algorimul de testare, apeland **force_stop_handler()** in cod
  * **void draw_straight_through_wiring()**, **void draw_crossover_wiring()**, **void draw_rollover_wiring()**:
    * Aceste functii afiseaza grafic ordinea firelor pentru cele doua capete ale unui cablu de retea
    * In functie de tipul de cablare selectat (straight-through/crossover/rollover)
    * Ordinea firelor este redata conform standardelor prezentate in **cursul de RL**
  * **setup()**
    * configureza pinii de Input/Outpt
    * activeaza intreruperile
    * initiaza display-urile
    * scrie in registrii
  * **loop()**
    * Verifica si trateaza flag-urile **pressedBTN1** si **pressedBTN3**
    * Reseteaza flag-urile
    * Ruleaza **delay()**

<note tip>NOTA: flag-ul **pressedBTN2** este tratat in interiorul algoritmului de testare (in functia **test_individual_rj45_pins()**)</note>



{{:pm:prj2025:ajipa:rj45-sw-code-img-01.png?400}}
{{:pm:prj2025:ajipa:rj45-sw-code-img-02.png?500}}
{{:pm:prj2025:ajipa:rj45-sw-code-img-03.png?500}}
{{:pm:prj2025:ajipa:rj45-sw-code-img-04.png?600}}
{{:pm:prj2025:ajipa:rj45-sw-code-img-05.png?400}}
{{:pm:prj2025:ajipa:rj45-sw-code-img-06.png?500}}
{{:pm:prj2025:ajipa:rj45-sw-code-img-07.png?400}}
{{:pm:prj2025:ajipa:rj45-sw-code-img-08.png?800}}
{{:pm:prj2025:ajipa:rj45-sw-code-img-09.png?800}}
{{:pm:prj2025:ajipa:rj45-sw-code-img-10.png?900}}



Repo GitHub: https://github.com/TrifanBogdan24/RJ45-tester

YouTube: https://www.youtube.com/shorts/l0MMbmgLmWM


===== Concluzii =====

  * Dat fiind faptul ca nu am avut succes la afisarea pe ecranul 160x128 a unor imagini **.bmp** luate de pe un card microSD, a trebuit sa renunt complet la modulul microSD
  * In alta ordine de idei, pentru a desena modul de cablare, am mers pe o idee mai programatica, **EGC**-style: m-am apucat si am desenat eu dreptunghiuri pe ecran, colorandu-ule corespunzator. Rezultatul final cred ca este mult mai bun decat daca as fi transformat niste screen-shoot-uri la imagini **.bmp** de rezolutie joasa
  * Cateva probleme pe care le-am intampinat in timpul acestui proiect au fost create de shift register-ul **74HC595** (cel cu 8 iesiri paralele):
    - Are o stare initiala random (am rezolvat scriind 0 logic pe toate iesirile)
    - Exista un delay (am observat ca este undeva la 200-300 ms) din momentul in care dau o valoare inspre shift register si momentul in care semnalul iese corect din acesta 
